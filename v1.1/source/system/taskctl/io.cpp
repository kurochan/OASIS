/*
 *  task.cpp
 *  OASIS Project
 *
 *  Created by Liva on 11/01/12.
 *  Generated by TDD
 *
 */

#include "kernel.h"

void PrepareIOTask(void){
	for(;;){
		taskctl.PrepareIOTask_O();
	}
}

void TASKCTL::PrepareIOTask_O(void){
	asm("cli");
	//I/O処理
	for(TASK *target=_io_task.taskNext;target!=&_idle_task;target=target->taskNext) {
		//I/O処理中は他のI/O処理を受け付けない
		if (target->status!=OPERATING_IO_FUNC){
			UINT data=target->inputfifo->get();
			if (data!=0){
				// 処理待ちのデータあり！
				if (target->status==WAITING_IO&&(data>>8)==target->ioWaitID){
					target->status=NOW_OPERATING;
					{
						TASK *task=&_io_task;
						for(;task->priorityNext->priority<target->priority;task=task->priorityNext){
							if (task->priorityNext==&_idle_task){
								panic();		//なんかよくわからんけど、指定されたタスクが存在しなかった
							}
						}
						target->priorityNext=task->priorityNext;
						task->priorityNext=target;
					}
				}else{
					//ここではタスクスイッチをせずにタスクを仮想タスクに切り替えるだけ
					CreateIOProc(target, data);
				}
			}
		}
	}

	asm("sti");
	_Tswitch();
	return ;
}

//Caller::Execute関数内では絶対に呼び出してはいけない！
void TASKCTL::WaitIO(const int _id){
	current->status=WAITING_IO;
	current->ioWaitID=_id ;
	SetInput( _id, (Caller *)0);
//@	asm("INT $0x40");
	Tswitch_V();
	return ;
}

void TASKCTL::CreateIOProc(TASK *target, UINT data){
	TASK *virtualIOProc		= (TASK *)taskmem->alloc();
	*virtualIOProc			= *target;

	virtualIOProc->parent = target;
	target->status			= OPERATING_IO_FUNC;
	virtualIOProc->priority = 1;
	virtualIOProc->iodata	= data;

	if (virtualIOProc->status==NOW_OPERATING){
		_DelCntFromPrtyLst();
	}

	{//線形リストの構築
		//優先度順に並べた時の線形リスト
		virtualIOProc->priorityNext	=_io_task.priorityNext;
		_io_task.priorityNext	= virtualIOProc;
	}
	set_segmdesc(TASK_GDT0 + virtualIOProc->pid, 103, (int) &(virtualIOProc->tss), AR_TSS32);

	asm volatile ("movl	$entry_IO,%0;":"=r"(virtualIOProc->tss.eip):);
	asm volatile ("movl %%eax,%0;":"=r"(virtualIOProc->tss.eax):);
	asm volatile ("movl %%ebx,%0;":"=r"(virtualIOProc->tss.ebx):);
	asm volatile ("movl %%ecx,%0;":"=r"(virtualIOProc->tss.ecx):);
	asm volatile ("movl %%edx,%0;":"=r"(virtualIOProc->tss.edx):);
	asm volatile ("movl %%esi,%0;":"=r"(virtualIOProc->tss.esi):);
	asm volatile ("movl %%edi,%0;":"=r"(virtualIOProc->tss.edi):);

	//entry以降のコードを削られないようにするための苦肉の策
	volatile bool hoge=1;
	if (hoge)
		return;
	asm ("entry_IO:");

	//IO処理
	current->stcaller[current->iodata>>8]->Execute((UCHAR)current->iodata&0xff);

	while(1){
		current->iodata=current->inputfifo->get();
		if(current->iodata==0){
			break;
		}
		// 処理待ちのデータあり！
		if (current->status==WAITING_IO&&(data>>8)==current->ioWaitID){
			current->status=NOW_OPERATING;
			{
				TASK *task=&_io_task;
				for(;task->priorityNext->priority<current->priority;task=task->priorityNext){
					if (task->priorityNext==&_idle_task){
						panic();		//なんかよくわからんけど、指定されたタスクが存在しなかった
					}
				}
				current->priorityNext=task->priorityNext;
				task->priorityNext=current;
			}
		}else{
			//ここではタスクスイッチをせずにタスクを仮想タスクに切り替えるだけ
			current->stcaller[current->iodata>>8]->Execute((UCHAR)current->iodata&0xff);
		}
	}

	//仮想タスク終了
	_procWaitingKilled->put((UINT)current);	//別のタスクに終了してもらうために処理待ちのキューに追加
	for(;;){
		_Tswitch();
		Tswitch_I(_io_task.pid);
		if (DEBUGG){
			static int x=1024*400;
			x++;
			sinfo->vram[x]=0xff;
		}
		
		/*
		 この二行の意味：
		 _Tswitch関数の方が処理が軽い。
		 ただし、_Tswitch関数では一部の場合Killできない事がある
		 そこで、処理は_Tswitchと比べて処理が重いものの、確実にKillできるTswitch_I関数を次に実行する
		 */
	}
}

void TASKCTL::_KillIOProc(void){
	
	if (_procWaitingKilled->status()==0){
		return;
	}

	TASK *task=(TASK *)_procWaitingKilled->get();

	//これではタスクスイッチができないので、とりあえず別の機会にやる
	if (current==task){
		_procWaitingKilled->put((UINT)task);
		return;
	}

	asm("cli");

	{
		TASK *target;
		for(target=&_io_task;target->priorityNext!=task;target=target->priorityNext){
			if (target->priorityNext==&_idle_task){
				panic();		//なんかよくわからんけど、指定されたタスクが存在しなかった
			}
		}
		target->priorityNext=task->priorityNext;
	}

	TASK *virtualIOProc		= task;
	TASK *parent			= task->parent;

	parent->status			= virtualIOProc->status;

	if (parent->status==NOW_OPERATING){
		TASK *target=&_io_task;
		for(;target->priorityNext->priority<parent->priority;target=target->priorityNext){
			if (target->priorityNext==&_idle_task){
				panic();		//なんかよくわからんけど、指定されたタスクが存在しなかった
			}
		}
		parent->priorityNext=target->priorityNext;
		target->priorityNext=parent;
	}

	set_segmdesc(TASK_GDT0 + parent->pid, 103, (int) &(parent->tss), AR_TSS32);

	asm("sti");
	taskmem->free_s(virtualIOProc);
	_KillIOProc();
	return;
}

